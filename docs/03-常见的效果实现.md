# Unity 常见效果实现

本文档介绍在自定义渲染管线中常见的渲染效果实现方式，包括实现原理、代码示例和最佳实践。

## 目录 (Table of Contents)

- [1. 轮廓线效果](#1-轮廓线效果)
  - [1.1 轮廓线效果概述](#11-轮廓线效果概述)
  - [1.2 基于顶点扩展的轮廓线](#12-基于顶点扩展的轮廓线)
  - [1.3 基于后处理的轮廓线](#13-基于后处理的轮廓线)
  - [1.4 使用 overrideMaterial 实现轮廓线](#14-使用-overridematerial-实现轮廓线)
  - [1.5 轮廓线效果的优缺点对比](#15-轮廓线效果的优缺点对比)
- [2. 阴影效果](#2-阴影效果)
  - [2.1 阴影贴图基础](#21-阴影贴图基础)
  - [2.2 ShadowCaster Pass 实现](#22-shadowcaster-pass-实现)
  - [2.3 阴影接收](#23-阴影接收)
- [3. 后处理效果](#3-后处理效果)
  - [3.1 后处理基础](#31-后处理基础)
  - [3.2 常见后处理效果](#32-常见后处理效果)
- [4. 水面效果](#4-水面效果)
  - [4.1 水面渲染基础](#41-水面渲染基础)
  - [4.2 水面波纹和反射](#42-水面波纹和反射)
- [5. 天空盒效果](#5-天空盒效果)
  - [5.1 天空盒渲染](#51-天空盒渲染)
  - [5.2 程序化天空盒](#52-程序化天空盒)
- [6. 深度可视化](#6-深度可视化)
  - [6.1 深度可视化概述](#61-深度可视化概述)
  - [6.2 基于 Shader Replacement 的深度可视化](#62-基于-shader-replacement-的深度可视化)
  - [6.3 深度可视化着色器实现](#63-深度可视化着色器实现)
  - [6.4 在 SRP 中实现深度可视化](#64-在-srp-中实现深度可视化)
  - [6.5 扩展应用](#65-扩展应用)
- [参考资源](#参考资源)

---

## 1. 轮廓线效果

### 1.1 轮廓线效果概述

轮廓线（Outline）是游戏中常用的视觉效果，用于突出显示选中的物体、区分敌我、或增强视觉表现力。

**常见实现方式：**

1. **基于顶点扩展的轮廓线**
   - 将顶点沿法线方向外扩
   - 适用于单个物体的轮廓线
   - 性能开销小，但效果受模型法线影响

2. **基于后处理的轮廓线**
   - 使用深度/法线信息检测边缘
   - 适用于全屏后处理
   - 性能开销较大，但效果统一

3. **基于 overrideMaterial 的轮廓线**
   - 使用覆盖材质重新渲染物体
   - 适用于需要批量处理的场景
   - 灵活性高，可以实现多种效果

### 1.2 基于顶点扩展的轮廓线

这是最简单直接的轮廓线实现方式，通过在原物体的基础上渲染一个稍微放大的单色版本来形成轮廓。

**实现原理：**

1. 第一个 Pass：正常渲染物体
2. 第二个 Pass：将顶点沿法线方向外扩，渲染单色背面

**Shader 代码示例：**

```hlsl
Shader "Custom/SimpleOutline"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _OutlineColor ("Outline Color", Color) = (0, 0, 0, 1)
        _OutlineWidth ("Outline Width", Range(0, 0.1)) = 0.03
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        
        // Pass 1: 正常渲染物体
        Pass
        {
            Name "ForwardLit"
            Tags { "LightMode"="UniversalForward" }
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };
            
            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
                float2 uv : TEXCOORD0;
            };
            
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _MainTex_ST;
            CBUFFER_END
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                VertexPositionInputs vertexInput = GetVertexPositionInputs(IN.positionOS.xyz);
                OUT.positionHCS = vertexInput.positionCS;
                OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex);
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                return color;
            }
            ENDHLSL
        }
        
        // Pass 2: 渲染轮廓线
        Pass
        {
            Name "Outline"
            Tags { "LightMode"="SRPDefaultUnlit" }
            
            Cull Front  // 只渲染背面
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
            };
            
            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
            };
            
            CBUFFER_START(UnityPerMaterial)
                float4 _OutlineColor;
                float _OutlineWidth;
            CBUFFER_END
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                // 将顶点沿法线方向外扩
                float3 expandedPosition = IN.positionOS.xyz + IN.normalOS * _OutlineWidth;
                VertexPositionInputs vertexInput = GetVertexPositionInputs(expandedPosition);
                OUT.positionHCS = vertexInput.positionCS;
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                return _OutlineColor;
            }
            ENDHLSL
        }
    }
}
```

**优点：**
- 实现简单，性能开销小
- 不需要额外的渲染 Pass 或后处理
- 可以在材质中直接调整轮廓宽度和颜色

**缺点：**
- 依赖模型法线质量，法线不平滑会导致轮廓不均匀
- 对于尖锐边缘或复杂模型效果可能不理想
- 只能在物体外侧显示轮廓，内侧凹陷处可能看不到

### 1.3 基于后处理的轮廓线

基于后处理的轮廓线通过分析深度、法线等信息来检测边缘，然后在这些边缘上绘制轮廓线。

**实现原理：**

1. 渲染场景到 RT，同时输出深度/法线信息
2. 在后处理阶段，使用边缘检测算法（如 Sobel 算子）检测边缘
3. 在检测到的边缘位置绘制轮廓线

**边缘检测方法：**

**Sobel 算子：**

使用 Sobel 算子计算深度或法线的梯度，梯度大的地方即为边缘。

```hlsl
// Sobel 边缘检测（深度）
float SobelDepth(float2 uv, Texture2D depthTex, SamplerState samplerState, float2 texelSize)
{
    // Sobel 核心矩阵（水平方向）
    float Gx[9] = {
        -1, 0, 1,
        -2, 0, 2,
        -1, 0, 1
    };
    
    // Sobel 核心矩阵（垂直方向）
    float Gy[9] = {
        -1, -2, -1,
         0,  0,  0,
         1,  2,  1
    };
    
    float gx = 0, gy = 0;
    
    // 采样 3x3 区域
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            float2 offset = float2(i - 1, j - 1) * texelSize;
            float depth = SAMPLE_TEXTURE2D(depthTex, samplerState, uv + offset).r;
            
            int index = i * 3 + j;
            gx += depth * Gx[index];
            gy += depth * Gy[index];
        }
    }
    
    // 计算梯度大小
    return sqrt(gx * gx + gy * gy);
}
```

**完整后处理轮廓线 Shader：**

```hlsl
Shader "Custom/PostProcessOutline"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _OutlineColor ("Outline Color", Color) = (0, 0, 0, 1)
        _OutlineThreshold ("Outline Threshold", Range(0, 1)) = 0.1
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        
        Pass
        {
            Name "OutlinePass"
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };
            
            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
                float2 uv : TEXCOORD0;
            };
            
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            TEXTURE2D(_CameraDepthTexture);
            SAMPLER(sampler_CameraDepthTexture);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _MainTex_ST;
                float4 _MainTex_TexelSize;
                float4 _OutlineColor;
                float _OutlineThreshold;
            CBUFFER_END
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex);
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                // 采样原始颜色
                half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                
                // Sobel 边缘检测
                float2 texelSize = _MainTex_TexelSize.xy;
                float edge = 0;
                
                // 简化的 Sobel 算子（只采样 4 个方向）
                float d0 = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, IN.uv + float2(-texelSize.x, 0)).r;
                float d1 = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, IN.uv + float2(texelSize.x, 0)).r;
                float d2 = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, IN.uv + float2(0, -texelSize.y)).r;
                float d3 = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, IN.uv + float2(0, texelSize.y)).r;
                
                float gx = abs(d1 - d0);
                float gy = abs(d3 - d2);
                edge = sqrt(gx * gx + gy * gy);
                
                // 如果边缘强度超过阈值，绘制轮廓线
                if (edge > _OutlineThreshold)
                {
                    return _OutlineColor;
                }
                
                return color;
            }
            ENDHLSL
        }
    }
}
```

**优点：**
- 效果统一，不依赖模型法线
- 可以检测任意类型的边缘（深度、法线、颜色等）
- 可以实现全屏轮廓线效果

**缺点：**
- 性能开销较大（全屏后处理）
- 需要额外的 Render Texture
- 可能会检测到不需要的边缘（如背景物体）

### 1.4 使用 overrideMaterial 实现轮廓线

在 URP 中，我们可以使用 `DrawingSettings.overrideMaterial` 来实现批量物体的轮廓线效果。这种方法的核心思想是：使用一个覆盖材质重新渲染场景中的物体，这个覆盖材质会将物体渲染为轮廓线的形状和颜色。

#### 什么是 overrideMaterial？

`overrideMaterial` 是 `DrawingSettings` 的一个属性，用于在渲染时强制替换物体的材质。当设置了 `overrideMaterial` 后：

- 所有被渲染的物体都会使用这个覆盖材质，而不是它们自己的材质
- 原始材质的着色器和属性都会被忽略
- 但物体的网格、变换等信息保持不变

**核心价值：**

`overrideMaterial` 的核心价值在于**将渲染对象与着色逻辑解耦**，使得我们可以用统一的着色方式处理多个不同的物体。这在以下场景中特别有用：

1. **阴影渲染**：所有物体都用同一个 ShadowCaster Shader 渲染深度
2. **轮廓线效果**：批量渲染物体的轮廓线
3. **特殊缓冲区生成**：如法线缓冲区、深度缓冲区等
4. **调试视图**：用统一的颜色或模式显示物体（如显示 UV、法线等）

#### 实现步骤

下面我们以 URP 为例，展示如何在自定义的 ScriptableRenderPass 中使用 overrideMaterial 来实现一个简单的物体轮廓线效果。

**步骤 1：创建覆盖材质**

首先，你需要一个用于覆盖的 Shader 和 Material。

1. 创建一个新的 Unlit Shader，命名为 `OutlineShader`
2. 编写 Shader 代码：这个 Shader 非常简单，只需输出一个固定的颜色（比如红色）

```hlsl
Shader "Custom/OutlineShader"
{
    Properties
    {
        _OutlineColor ("Outline Color", Color) = (1, 0, 0, 1)
        _OutlineThickness ("Outline Thickness", Float) = 0.03
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        Pass
        {
            Name "OutlinePass"
            
            // 稍微向前偏移一点，防止深度冲突
            Offset -1, -1
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
            };
            
            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
            };
            
            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                float _OutlineThickness;
            CBUFFER_END
            
            // 让顶点沿着法线方向外扩一点，形成轮廓
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                // 将顶点沿法线方向外扩
                float3 expandedPosition = IN.positionOS.xyz + IN.normalOS * _OutlineThickness;
                VertexPositionInputs vertexInput = GetVertexPositionInputs(expandedPosition);
                OUT.positionHCS = vertexInput.positionCS;
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                return _OutlineColor;
            }
            ENDHLSL
        }
    }
}
```

3. 在项目中，右键 -> Create -> Material，使用这个 Shader，命名为 `OutlineMaterial`
4. 将 Outline Color 设置为你想要的轮廓颜色（如红色）

**步骤 2：创建自定义 Renderer Feature 和 Render Pass**

创建一个 C# 脚本，命名为 `OutlineRenderFeature.cs`，在其中创建 `OutlineRenderPass` 类。

```csharp
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class OutlineRenderFeature : ScriptableRendererFeature
{
    // 在 Inspector 中暴露设置，方便配置
    [System.Serializable]
    public class Settings
    {
        public Material overrideMaterial; // 这里拖入我们创建的 OutlineMaterial
        public LayerMask layerMask = -1; // 指定对哪些层级的物体生效
        public RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
    }

    public Settings settings = new Settings();
    private OutlineRenderPass _renderPass;

    public override void Create()
    {
        _renderPass = new OutlineRenderPass(settings);
    }

    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        // 只有当提供了有效的覆盖材质时才添加这个 Pass
        if (settings.overrideMaterial != null)
        {
            renderer.EnqueuePass(_renderPass);
        }
    }
}

public class OutlineRenderPass : ScriptableRenderPass
{
    private Material _overrideMaterial;
    private LayerMask _layerMask;
    private FilteringSettings _filteringSettings;

    // 用于指定渲染队列，这里我们渲染不透明物体
    private RenderQueueRange _renderQueueRange = RenderQueueRange.opaque;

    // 用于存储渲染时的 Shader Tag，通常使用 "SRPDefaultUnlit" 或 "UniversalForward"
    private ShaderTagId _shaderTagId = new ShaderTagId("UniversalForward");

    public OutlineRenderPass(OutlineRenderFeature.Settings settings)
    {
        this._overrideMaterial = settings.overrideMaterial;
        this._layerMask = settings.layerMask;
        this.renderPassEvent = settings.renderPassEvent; // 在不透明物体渲染完成后执行

        // 配置过滤设置：渲染哪些物体
        _filteringSettings = new FilteringSettings(_renderQueueRange, _layerMask);
    }

    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
    {
        // 1. 创建绘制设置 (DrawingSettings)
        DrawingSettings drawingSettings = CreateDrawingSettings(
            _shaderTagId, 
            ref renderingData, 
            renderingData.cameraData.defaultOpaqueSortFlags
        );

        // 2. 【核心】设置覆盖材质
        drawingSettings.overrideMaterial = _overrideMaterial;
        
        // 可选：如果你希望覆盖材质对所有 SubShader 都生效，可以设置这个
        drawingSettings.overrideMaterialPassIndex = 0; // 使用覆盖材质的第一个 Pass

        // 3. 执行绘制命令
        // 这个调用会根据 _filteringSettings 过滤出场景中的渲染器，
        // 并使用 drawingSettings 中的设置（包括我们的覆盖材质）来绘制它们。
        context.DrawRenderers(
            renderingData.cullResults, 
            ref drawingSettings, 
            ref _filteringSettings
        );
    }
}
```

**步骤 3：配置并使用**

1. 将 `OutlineRenderFeature` 添加到你的 URP Renderer Asset 中
   - 打开 Project Settings -> Graphics -> 找到你正在使用的 URP Renderer Asset
   - 在 Renderer Features 列表中添加 OutlineRenderFeature

2. 在 Inspector 中，将之前创建的 `OutlineMaterial` 拖拽到 Feature 的 Override Material 字段上

3. 运行游戏。你应该能看到场景中所有不透明物体都被一个红色的轮廓包围了。

**关键代码解析：**

```csharp
// 创建绘制设置
DrawingSettings drawingSettings = CreateDrawingSettings(
    _shaderTagId,           // 指定要渲染的 Pass（通过 LightMode 标签匹配）
    ref renderingData,       // 渲染数据
    SortingCriteria.CommonOpaque  // 排序方式
);

// 设置覆盖材质（核心）
drawingSettings.overrideMaterial = _overrideMaterial;
drawingSettings.overrideMaterialPassIndex = 0;  // 使用覆盖材质的第一个 Pass

// 执行绘制
context.DrawRenderers(
    cullingResults,          // 剔除结果（哪些物体可见）
    ref drawingSettings,     // 绘制设置（包含覆盖材质）
    ref _filteringSettings   // 过滤设置（图层、队列等）
);
```

**工作流程：**

```text
1. Unity 遍历场景中的所有 Renderer
   ↓
2. 根据 FilteringSettings 过滤（图层、队列等）
   ↓
3. 对于每个通过过滤的 Renderer：
   - 忽略其原始 Material
   - 使用 drawingSettings.overrideMaterial 代替
   - 使用覆盖材质的指定 Pass 进行渲染
   ↓
4. 结果：所有物体都用同一个覆盖材质渲染
```

#### 高级用法

**1. 多 Pass 轮廓线：**

可以先渲染正常物体，然后再用覆盖材质渲染轮廓线：

```csharp
public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
{
    // Pass 1: 正常渲染（不设置 overrideMaterial）
    DrawingSettings normalDrawing = CreateDrawingSettings(
        _shaderTagId, 
        ref renderingData, 
        SortingCriteria.CommonOpaque
    );
    context.DrawRenderers(
        renderingData.cullResults, 
        ref normalDrawing, 
        ref _filteringSettings
    );

    // Pass 2: 轮廓线渲染（设置 overrideMaterial）
    DrawingSettings outlineDrawing = CreateDrawingSettings(
        _shaderTagId, 
        ref renderingData, 
        SortingCriteria.CommonOpaque
    );
    outlineDrawing.overrideMaterial = _overrideMaterial;
    outlineDrawing.overrideMaterialPassIndex = 0;
    
    context.DrawRenderers(
        renderingData.cullResults, 
        ref outlineDrawing, 
        ref _filteringSettings
    );
}
```

**2. 基于 Layer 的选择性轮廓线：**

通过设置 `LayerMask`，只对特定图层的物体应用轮廓线：

```csharp
// 在 Inspector 中设置 Layer Mask（如只对 "Player" 和 "Enemy" 图层生效）
public LayerMask layerMask = -1;

// 在 OutlineRenderPass 中使用
_filteringSettings = new FilteringSettings(_renderQueueRange, layerMask);
```

**3. 动态切换轮廓线材质：**

可以在运行时动态切换轮廓线的颜色或样式：

```csharp
// 在 OutlineRenderFeature 中添加
public void SetOutlineColor(Color color)
{
    if (settings.overrideMaterial != null)
    {
        settings.overrideMaterial.SetColor("_OutlineColor", color);
    }
}

// 在游戏代码中调用
var renderer = FindObjectOfType<UniversalRenderPipelineAsset>();
var feature = renderer.GetRenderer(0).GetComponent<OutlineRenderFeature>();
feature.SetOutlineColor(Color.green);  // 动态改变轮廓线颜色
```

#### 总结

**DrawingSettings.overrideMaterial 的核心价值：**

1. **批量处理**：可以用统一的方式处理多个物体，无需修改每个物体的材质
2. **解耦渲染逻辑**：将渲染对象与着色逻辑分离，提高代码的灵活性和可维护性
3. **性能优化**：避免创建大量的材质实例，减少内存占用和状态切换
4. **实现特殊效果**：轻松实现轮廓线、阴影、调试视图等需要统一着色的效果

**使用场景：**

- ✅ 阴影投射（ShadowCaster Pass）
- ✅ 轮廓线效果
- ✅ 深度/法线缓冲区生成
- ✅ 调试视图（显示 UV、法线、光照等）
- ✅ 选中高亮效果
- ✅ X-Ray 透视效果

**使用步骤总结：**

1. 准备一个用于覆盖的 Shader 和 Material
2. 在自定义的 ScriptableRenderPass 中配置 DrawingSettings
3. 将 `drawingSettings.overrideMaterial` 设置为你的覆盖材质
4. 通过 `context.DrawRenderers` 结合 FilteringSettings 来执行绘制

### 1.5 轮廓线效果的优缺点对比

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **顶点扩展** | 性能好，实现简单 | 依赖法线质量，可能不均匀 | 单个物体轮廓线，性能敏感场景 |
| **后处理** | 效果统一，不依赖法线 | 性能开销大，需要额外 RT | 全屏效果，视觉质量优先 |
| **overrideMaterial** | 灵活性高，易于批量处理 | 需要自定义 Render Pass | 批量物体轮廓线，选中高亮 |

**最佳实践建议：**

1. **移动平台**：优先使用顶点扩展方法，性能最优
2. **PC/主机平台**：可以使用后处理或 overrideMaterial 方法，效果更好
3. **动态选择**：根据物体类型动态选择方法（如角色用顶点扩展，建筑用后处理）
4. **性能监控**：使用 Unity Profiler 监控性能，确保帧率稳定

[↑ 返回目录](#目录-table-of-contents)

---

## 2. 阴影效果

### 2.1 阴影贴图基础

阴影贴图（Shadow Mapping）是实时阴影渲染的标准技术。

**基本原理：**

1. 从光源视角渲染场景，记录深度信息到阴影贴图
2. 从相机视角渲染场景时，将像素位置变换到光源空间
3. 比较像素深度与阴影贴图中的深度，判断是否在阴影中

**实现流程：**

```text
1. Shadow Pass：从光源视角渲染深度
   ↓
2. 存储深度到 Shadow Map（RT）
   ↓
3. Main Pass：从相机视角渲染
   ↓
4. 采样 Shadow Map，比较深度
   ↓
5. 计算阴影强度
```

### 2.2 ShadowCaster Pass 实现

ShadowCaster Pass 用于渲染阴影投射物体的深度信息。

**Shader 实现：**

```hlsl
Pass
{
    Name "ShadowCaster"
    Tags { "LightMode"="ShadowCaster" }

    ZWrite On
    ZTest LEqual
    ColorMask 0  // 不写入颜色，只写入深度

    HLSLPROGRAM
    #pragma vertex vert
    #pragma fragment frag
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"

    struct Attributes
    {
        float4 positionOS : POSITION;
        float3 normalOS : NORMAL;
    };

    struct Varyings
    {
        float4 positionCS : SV_POSITION;
    };

    Varyings vert(Attributes IN)
    {
        Varyings OUT;
        
        // 应用阴影偏移，避免阴影失真
        float3 positionWS = TransformObjectToWorld(IN.positionOS.xyz);
        float3 normalWS = TransformObjectToWorldNormal(IN.normalOS);
        
        // 从光源方向偏移一点，避免自阴影
        positionWS = ApplyShadowBias(positionWS, normalWS, _LightDirection);
        
        OUT.positionCS = TransformWorldToHClip(positionWS);
        return OUT;
    }

    half4 frag(Varyings IN) : SV_Target
    {
        return 0;  // 只写入深度，不需要输出颜色
    }
    ENDHLSL
}
```

**关键点：**

1. **ColorMask 0**：只写入深度，不写入颜色，提高性能
2. **Shadow Bias**：避免自阴影（Shadow Acne）
3. **ZTest LEqual**：深度测试，只渲染最近的表面

### 2.3 阴影接收

在主渲染 Pass 中接收阴影。

**Shader 实现：**

```hlsl
Pass
{
    Name "ForwardLit"
    Tags { "LightMode"="UniversalForward" }

    HLSLPROGRAM
    #pragma vertex vert
    #pragma fragment frag
    
    // 启用阴影关键字
    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
    
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

    struct Attributes
    {
        float4 positionOS : POSITION;
        float3 normalOS : NORMAL;
    };

    struct Varyings
    {
        float4 positionCS : SV_POSITION;
        float3 positionWS : TEXCOORD0;
        float3 normalWS : TEXCOORD1;
    };

    Varyings vert(Attributes IN)
    {
        Varyings OUT;
        OUT.positionWS = TransformObjectToWorld(IN.positionOS.xyz);
        OUT.positionCS = TransformWorldToHClip(OUT.positionWS);
        OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);
        return OUT;
    }

    half4 frag(Varyings IN) : SV_Target
    {
        // 计算光照
        Light mainLight = GetMainLight();
        
        // 获取阴影坐标
        float4 shadowCoord = TransformWorldToShadowCoord(IN.positionWS);
        
        // 采样阴影贴图
        float shadowAttenuation = MainLightRealtimeShadow(shadowCoord);
        
        // 应用阴影到光照
        half3 lighting = mainLight.color * mainLight.distanceAttenuation * shadowAttenuation;
        
        // 计算最终颜色
        half3 diffuse = lighting * saturate(dot(IN.normalWS, mainLight.direction));
        
        return half4(diffuse, 1.0);
    }
    ENDHLSL
}
```

**关键函数：**

- `TransformWorldToShadowCoord()`：将世界空间坐标转换到阴影空间
- `MainLightRealtimeShadow()`：采样阴影贴图，返回阴影衰减值（0=完全阴影，1=无阴影）
- `GetMainLight()`：获取主光源信息

[↑ 返回目录](#目录-table-of-contents)

---

## 3. 后处理效果

### 3.1 后处理基础

后处理（Post-Processing）是在渲染完成后对图像进行的额外处理。

**后处理流程：**

```text
1. 渲染场景到 Render Texture
   ↓
2. 应用后处理效果（全屏 Shader）
   ↓
3. 输出到屏幕或下一个 RT
```

**在 URP 中实现后处理：**

```csharp
public class CustomPostProcessPass : ScriptableRenderPass
{
    private Material _material;
    private RenderTargetIdentifier _source;
    private RenderTargetHandle _tempRT;

    public CustomPostProcessPass(Material material)
    {
        _material = material;
        _tempRT.Init("_TempRT");
    }

    public void Setup(RenderTargetIdentifier source)
    {
        _source = source;
    }

    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
    {
        CommandBuffer cmd = CommandBufferPool.Get("Custom Post Process");

        // 获取临时 RT
        RenderTextureDescriptor desc = renderingData.cameraData.cameraTargetDescriptor;
        cmd.GetTemporaryRT(_tempRT.id, desc);

        // 应用后处理
        cmd.Blit(_source, _tempRT.Identifier(), _material, 0);
        cmd.Blit(_tempRT.Identifier(), _source);

        // 释放临时 RT
        cmd.ReleaseTemporaryRT(_tempRT.id);

        context.ExecuteCommandBuffer(cmd);
        CommandBufferPool.Release(cmd);
    }
}
```

### 3.2 常见后处理效果

**1. Bloom（泛光）：**

```hlsl
// 简化的 Bloom 实现
half4 frag(Varyings IN) : SV_Target
{
    half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
    
    // 提取亮部
    half brightness = max(color.r, max(color.g, color.b));
    half contribution = max(0, brightness - _Threshold);
    contribution /= max(brightness, 0.00001);
    
    // 应用 Bloom
    half4 bloom = color * contribution;
    
    return color + bloom * _Intensity;
}
```

**2. Vignette（暗角）：**

```hlsl
half4 frag(Varyings IN) : SV_Target
{
    half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
    
    // 计算到中心的距离
    float2 center = IN.uv - 0.5;
    float dist = length(center);
    
    // 应用暗角
    float vignette = smoothstep(_OuterRadius, _InnerRadius, dist);
    
    return color * vignette;
}
```

**3. Color Grading（颜色分级）：**

```hlsl
half4 frag(Varyings IN) : SV_Target
{
    half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
    
    // 调整饱和度
    half gray = dot(color.rgb, half3(0.299, 0.587, 0.114));
    color.rgb = lerp(gray, color.rgb, _Saturation);
    
    // 调整对比度
    color.rgb = (color.rgb - 0.5) * _Contrast + 0.5;
    
    // 调整亮度
    color.rgb *= _Brightness;
    
    return color;
}
```

[↑ 返回目录](#目录-table-of-contents)

---

## 4. 水面效果

### 4.1 水面渲染基础

水面渲染通常包括以下特性：

1. **波纹动画**：使用法线贴图和时间参数
2. **反射**：屏幕空间反射或反射探针
3. **折射**：扭曲背景
4. **菲涅尔效果**：边缘透明，正面反射

**简单水面 Shader：**

```hlsl
Shader "Custom/SimpleWater"
{
    Properties
    {
        _WaterColor ("Water Color", Color) = (0, 0.5, 1, 1)
        _NormalMap ("Normal Map", 2D) = "bump" {}
        _WaveSpeed ("Wave Speed", Float) = 1.0
        _WaveScale ("Wave Scale", Float) = 1.0
    }
    SubShader
    {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" }
        
        Pass
        {
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };
            
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 viewDir : TEXCOORD1;
            };
            
            TEXTURE2D(_NormalMap);
            SAMPLER(sampler_NormalMap);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _WaterColor;
                float4 _NormalMap_ST;
                float _WaveSpeed;
                float _WaveScale;
            CBUFFER_END
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = TRANSFORM_TEX(IN.uv, _NormalMap);
                
                float3 positionWS = TransformObjectToWorld(IN.positionOS.xyz);
                OUT.viewDir = GetWorldSpaceViewDir(positionWS);
                
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                // 采样法线贴图（使用时间偏移制造波纹动画）
                float2 uv1 = IN.uv + _Time.y * _WaveSpeed * float2(0.1, 0.1);
                float2 uv2 = IN.uv - _Time.y * _WaveSpeed * float2(0.05, 0.08);
                
                half3 normal1 = UnpackNormal(SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, uv1));
                half3 normal2 = UnpackNormal(SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, uv2));
                half3 normal = normalize(normal1 + normal2);
                
                // 菲涅尔效果
                float fresnel = pow(1.0 - saturate(dot(normalize(IN.viewDir), normal)), 5.0);
                
                // 最终颜色
                half4 color = _WaterColor;
                color.a = lerp(0.3, 0.9, fresnel);
                
                return color;
            }
            ENDHLSL
        }
    }
}
```

### 4.2 水面波纹和反射

**更高级的水面效果需要：**

1. **反射探针**：捕捉环境反射
2. **屏幕空间反射（SSR）**：实时反射
3. **深度信息**：计算水深，调整颜色
4. **泡沫效果**：在岸边添加泡沫

**实现建议：**

- 使用 URP 的反射探针系统
- 利用深度纹理计算水深
- 使用噪声纹理生成泡沫

[↑ 返回目录](#目录-table-of-contents)

---

## 5. 天空盒效果

### 5.1 天空盒渲染

天空盒（Skybox）通常在渲染流程的最开始或最后渲染。

**在自定义 RP 中渲染天空盒：**

```csharp
public void Render(ScriptableRenderContext context, Camera camera)
{
    // ...其他设置...
    
    // 渲染天空盒
    context.DrawSkybox(camera);
    
    // ...其他渲染...
}
```

**天空盒 Shader 基础：**

```hlsl
Shader "Custom/SimpleSkybox"
{
    Properties
    {
        _SkyColor ("Sky Color", Color) = (0.5, 0.7, 1, 1)
        _HorizonColor ("Horizon Color", Color) = (1, 0.8, 0.6, 1)
    }
    SubShader
    {
        Tags { "Queue"="Background" "RenderType"="Background" "PreviewType"="Skybox" }
        Cull Off
        ZWrite Off
        
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
            };
            
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float3 viewDir : TEXCOORD0;
            };
            
            CBUFFER_START(UnityPerMaterial)
                half4 _SkyColor;
                half4 _HorizonColor;
            CBUFFER_END
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.viewDir = IN.positionOS.xyz;
                return OUT;
            }
            
            half4 frag(Varyings IN) : SV_Target
            {
                float3 viewDir = normalize(IN.viewDir);
                float t = saturate(viewDir.y);
                
                // 从地平线颜色渐变到天空颜色
                half4 color = lerp(_HorizonColor, _SkyColor, t);
                
                return color;
            }
            ENDHLSL
        }
    }
}
```

### 5.2 程序化天空盒

程序化天空盒可以根据时间、天气等因素动态生成。

**简单的程序化天空盒：**

```hlsl
half4 frag(Varyings IN) : SV_Target
{
    float3 viewDir = normalize(IN.viewDir);
    
    // 太阳方向
    float3 sunDir = normalize(float3(0.3, 0.5, 0.2));
    
    // 天空渐变
    float skyGradient = pow(saturate(viewDir.y), 0.5);
    half3 skyColor = lerp(_HorizonColor.rgb, _SkyColor.rgb, skyGradient);
    
    // 太阳
    float sunDot = saturate(dot(viewDir, sunDir));
    half3 sunColor = _SunColor.rgb * pow(sunDot, _SunSize);
    
    // 合成
    half3 finalColor = skyColor + sunColor;
    
    return half4(finalColor, 1.0);
}
```

**高级特性：**

- 云层渲染（使用噪声纹理）
- 星空效果
- 大气散射
- 昼夜循环

[↑ 返回目录](#目录-table-of-contents)

## 6. 深度可视化

### 6.1 深度可视化概述

深度可视化（Depth Visualization）是一种常用的调试和可视化工具，用于在开发过程中直观地查看场景的深度信息。它将深度值转换为颜色，帮助开发者理解场景的空间结构和深度关系。

**应用场景：**

1. **调试工具**：在开发过程中快速识别深度问题（如 Z-fighting、深度排序错误）
2. **性能分析**：理解场景的深度分布，优化渲染顺序
3. **效果开发**：用于深度相关的后处理效果开发（如 SSAO、景深）
4. **教学演示**：可视化深度缓冲区的原理

**实现方式：**

1. **基于 Shader Replacement**（本小节重点）
   - 使用 `Camera.SetReplacementShader()` 替换所有对象的着色器
   - 统一渲染深度信息，不受原始材质影响
   - 适用于调试和可视化

2. **基于后处理**
   - 读取深度纹理（Depth Texture）
   - 通过后处理着色器可视化
   - 可以叠加在正常渲染之上

3. **基于 overrideMaterial**
   - 使用 `DrawingSettings.overrideMaterial` 覆盖材质
   - 在 SRP 中更灵活，可以精确控制

### 6.2 基于 Shader Replacement 的深度可视化

**工作原理：**

深度可视化通过 Shader Replacement 实现，其工作流程如下：

```text
1. 创建深度可视化着色器（Depth Visualization Shader）
   └─ 输入：顶点位置
   └─ 输出：深度值转换为颜色

2. 调用 Camera.SetReplacementShader()
   └─ 将所有 RenderType="Opaque" 的对象替换为深度可视化着色器

3. 渲染时
   └─ 每个对象使用深度可视化着色器
   └─ 计算其深度值并转换为颜色
   └─ 输出到屏幕

4. 恢复正常渲染
   └─ 调用 Camera.ResetReplacementShader()
```

**核心优势：**

- ✅ **统一处理**：所有对象使用相同的深度可视化逻辑，不受材质影响
- ✅ **简单易用**：只需调用两个 API 即可启用/禁用
- ✅ **性能友好**：只在需要时启用，不影响正常渲染
- ✅ **直观清晰**：深度信息直接转换为颜色，一目了然

### 6.3 深度可视化着色器实现

**完整的深度可视化着色器：**

```hlsl
Shader "Custom/DepthVisualization"
{
    Properties
    {
        _NearColor ("Near Color", Color) = (1, 1, 1, 1)  // 近处颜色（白色）
        _FarColor ("Far Color", Color) = (0, 0, 0, 1)     // 远处颜色（黑色）
        _DepthRange ("Depth Range", Vector) = (0, 100, 0, 0)  // 深度范围（最小、最大）
    }
    
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        
        Pass
        {
            Name "DepthVisualization"
            Tags { "LightMode"="SRPDefaultUnlit" }
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
            };
            
            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
                float depth : TEXCOORD0;
            };
            
            CBUFFER_START(UnityPerMaterial)
                float4 _NearColor;
                float4 _FarColor;
                float2 _DepthRange;  // x = min, y = max
            CBUFFER_END
            
            Varyings vert(Attributes input)
            {
                Varyings output;
                
                // 转换到裁剪空间
                output.positionHCS = TransformObjectToHClip(input.positionOS.xyz);
                
                // 计算深度值（在裁剪空间中，z/w 是归一化的深度）
                // 范围通常是 -1（近平面）到 1（远平面），但需要转换到 0-1
                output.depth = output.positionHCS.z / output.positionHCS.w;
                
                return output;
            }
            
            half4 frag(Varyings input) : SV_Target
            {
                // 将深度值从 [-1, 1] 转换为 [0, 1]
                // 注意：实际的深度值范围取决于投影矩阵的设置
                float depth = input.depth * 0.5 + 0.5;
                
                // 可选：应用深度范围限制
                float depthRange = _DepthRange.y - _DepthRange.x;
                if (depthRange > 0)
                {
                    depth = saturate((depth - _DepthRange.x) / depthRange);
                }
                
                // 在近处颜色和远处颜色之间插值
                half4 color = lerp(_NearColor, _FarColor, depth);
                
                return color;
            }
            ENDHLSL
        }
    }
    
    // 可选：为透明对象提供支持
    SubShader
    {
        Tags { "RenderType"="Transparent" }
        
        Pass
        {
            Name "DepthVisualizationTransparent"
            Tags { "LightMode"="SRPDefaultUnlit" }
            
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            // 与上面相同的代码...
            // ...
            ENDHLSL
        }
    }
    
    Fallback Off
}
```

**关键代码解析：**

1. **深度计算**：
   ```hlsl
   output.depth = output.positionHCS.z / output.positionHCS.w;
   ```
   在裁剪空间中，深度值通过 z/w 计算得出。

2. **深度归一化**：
   ```hlsl
   float depth = input.depth * 0.5 + 0.5;
   ```
   将深度值从 [-1, 1] 范围转换到 [0, 1] 范围。

3. **颜色插值**：
   ```hlsl
   half4 color = lerp(_NearColor, _FarColor, depth);
   ```
   根据深度值在近处颜色和远处颜色之间插值。

**C# 使用代码：**

```csharp
using UnityEngine;

public class DepthVisualization : MonoBehaviour
{
    [Header("Debug Settings")]
    public bool enableDepthVisualization = false;
    public Color nearColor = Color.white;      // 近处为白色
    public Color farColor = Color.black;       // 远处为黑色
    public Vector2 depthRange = new Vector2(0, 100);  // 深度范围
    
    private Camera targetCamera;
    private Shader depthVisualizationShader;
    private Material depthVisualizationMaterial;
    
    void Start()
    {
        targetCamera = GetComponent<Camera>();
        depthVisualizationShader = Shader.Find("Custom/DepthVisualization");
        
        if (depthVisualizationShader != null)
        {
            depthVisualizationMaterial = new Material(depthVisualizationShader);
        }
    }
    
    void Update()
    {
        if (enableDepthVisualization && depthVisualizationShader != null)
        {
            // 更新材质属性
            depthVisualizationMaterial.SetColor("_NearColor", nearColor);
            depthVisualizationMaterial.SetColor("_FarColor", farColor);
            depthVisualizationMaterial.SetVector("_DepthRange", depthRange);
            
            // 启用深度可视化
            targetCamera.SetReplacementShader(depthVisualizationShader, "RenderType");
        }
        else
        {
            // 恢复正常渲染
            targetCamera.ResetReplacementShader();
        }
    }
    
    void OnDisable()
    {
        // 确保在禁用时恢复正常渲染
        if (targetCamera != null)
        {
            targetCamera.ResetReplacementShader();
        }
    }
}
```

**使用方式：**

1. 将脚本添加到相机上
2. 在 Inspector 中勾选 `Enable Depth Visualization`
3. 调整 `Near Color` 和 `Far Color` 来控制颜色映射
4. 调整 `Depth Range` 来限制显示的深度范围

### 6.4 在 SRP 中实现深度可视化

在 Scriptable Render Pipeline 中，由于 `SetReplacementShader` 可能不被自动支持，我们需要在渲染管线中手动实现。

**在 CameraRenderer 中实现：**

```csharp
// CameraRenderer.cs
public partial class CameraRenderer
{
    private Shader replacementShader;
    private string replacementTag;
    
    // 设置替换着色器
    public void SetReplacementShader(Shader shader, string tag)
    {
        replacementShader = shader;
        replacementTag = tag;
    }
    
    public void ResetReplacementShader()
    {
        replacementShader = null;
        replacementTag = null;
    }
    
    private void DrawVisibleObjects()
    {
        var sortingSettings = new SortingSettings(camera)
        {
            criteria = SortingCriteria.CommonOpaque
        };
        
        var drawingSettings = new DrawingSettings(
            new ShaderTagId("SRPDefaultUnlit"),
            sortingSettings
        );
        
        // 如果设置了替换着色器，使用它
        if (replacementShader != null)
        {
            drawingSettings.overrideShader = replacementShader;
            drawingSettings.overrideShaderPassIndex = 0;
        }
        
        var filteringSettings = new FilteringSettings(RenderQueueRange.opaque);
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
    }
}
```

**使用示例：**

```csharp
// 在 CustomRenderPipeline 或外部脚本中
CameraRenderer renderer = // ... 获取 renderer

// 启用深度可视化
Shader depthShader = Shader.Find("Custom/DepthVisualization");
renderer.SetReplacementShader(depthShader, "RenderType");

// 恢复正常渲染
renderer.ResetReplacementShader();
```

### 6.5 扩展应用

**1. 法线可视化**

使用相同的方法可以可视化法线方向：

```hlsl
half4 frag(Varyings input) : SV_Target
{
    // 将法线从 [-1, 1] 转换到 [0, 1]
    float3 normal = input.worldNormal * 0.5 + 0.5;
    return half4(normal, 1.0);
}
```

**2. UV 坐标可视化**

可视化纹理坐标：

```hlsl
half4 frag(Varyings input) : SV_Target
{
    // 直接输出 UV 坐标作为颜色
    return half4(input.uv, 0.0, 1.0);
}
```

**3. 世界空间位置可视化**

可视化世界空间坐标：

```hlsl
half4 frag(Varyings input) : SV_Target
{
    // 将世界空间位置转换为颜色
    float3 worldPos = input.worldPos;
    // 归一化到 [0, 1] 范围
    float3 color = (worldPos + 50.0) / 100.0;  // 假设场景范围在 -50 到 50
    return half4(color, 1.0);
}
```

**4. 热力图效果**

根据深度值创建热力图：

```hlsl
half4 frag(Varyings input) : SV_Target
{
    float depth = input.depth * 0.5 + 0.5;
    
    // 使用梯度颜色（蓝色->绿色->红色）
    half4 color;
    if (depth < 0.33)
    {
        // 蓝色到绿色
        color = lerp(half4(0, 0, 1, 1), half4(0, 1, 0, 1), depth / 0.33);
    }
    else if (depth < 0.66)
    {
        // 绿色到黄色
        color = lerp(half4(0, 1, 0, 1), half4(1, 1, 0, 1), (depth - 0.33) / 0.33);
    }
    else
    {
        // 黄色到红色
        color = lerp(half4(1, 1, 0, 1), half4(1, 0, 0, 1), (depth - 0.66) / 0.34);
    }
    
    return color;
}
```

**5. 调试工具集成**

创建一个统一的调试工具类：

```csharp
public enum DebugVisualizationMode
{
    None,
    Depth,
    Normals,
    UV,
    WorldPosition
}

public class DebugVisualization : MonoBehaviour
{
    public DebugVisualizationMode mode = DebugVisualizationMode.None;
    public Camera targetCamera;
    
    private Shader[] debugShaders;
    
    void Update()
    {
        if (mode == DebugVisualizationMode.None)
        {
            targetCamera.ResetReplacementShader();
        }
        else
        {
            Shader shader = debugShaders[(int)mode - 1];
            targetCamera.SetReplacementShader(shader, "RenderType");
        }
    }
}
```

**最佳实践：**

1. **性能考虑**：只在开发/调试时启用，发布版本中应完全移除
2. **条件编译**：使用 `#if UNITY_EDITOR` 或 `#if DEVELOPMENT_BUILD` 限制调试功能
3. **统一管理**：创建统一的调试工具类，方便切换不同的可视化模式
4. **清晰标识**：使用明显的颜色方案，确保深度信息易于理解

**注意事项：**

1. **深度值范围**：不同平台和渲染设置可能产生不同的深度值范围，需要根据实际情况调整
2. **透明对象**：默认实现可能不包含透明对象，如需支持需要添加对应的 SubShader
3. **SRP 兼容性**：在 SRP 中可能需要手动实现 Shader Replacement 逻辑

[↑ 返回目录](#目录-table-of-contents)

---

## 参考资源

- [Unity 官方文档 - Scriptable Render Pipeline](https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html)
- [Unity 官方文档 - URP Renderer Features](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest)
- [Catlike Coding - Custom SRP 教程](https://catlikecoding.com/unity/tutorials/custom-srp)
- [Unity 官方示例 - Boat Attack](https://github.com/Unity-Technologies/BoatAttack)
- [Ben Cloward - Shader Tutorials](https://www.youtube.com/c/BenCloward)

[↑ 返回目录](#目录-table-of-contents)

---

## TODO

待添加的内容：

- [ ] 实时全局光照（GI）实现
- [ ] 体积光效果
- [ ] 景深（Depth of Field）效果
- [ ] 运动模糊（Motion Blur）效果
- [ ] 屏幕空间环境光遮蔽（SSAO）
- [ ] 屏幕空间反射（SSR）
- [ ] 粒子系统集成
- [ ] 卡通渲染（NPR）
- [ ] 毛发渲染
- [ ] 透明物体排序和渲染

### overrideMaterial 的更多应用场景（待细化）

以下是 `overrideMaterial` 在实际项目中的常见用途，后续将为每个场景提供详细的实现代码和说明：

#### 1. 阴影投射（Shadow Casting）

**应用场景：**
在渲染阴影贴图（Shadow Map）时，通常不需要复杂的表面着色。使用一个简化的、只计算深度/阴影的材质来覆盖所有物体的原有材质，可以极大地提升阴影渲染的性能和稳定性。

**核心优势：**
- ✅ 简化着色计算，只输出深度信息
- ✅ 避免复杂的纹理采样和光照计算
- ✅ 统一处理所有投射阴影的物体
- ✅ 显著提升 Shadow Pass 的渲染性能

**实现要点：**
- 使用 `ColorMask 0`，只写入深度
- 应用阴影偏移（Shadow Bias）避免自阴影
- 支持 Alpha Test 物体的透明度裁剪

#### 2. 深度/法线纹理生成

**应用场景：**
在生成用于后期效果的深度图或法线图时，可以使用一个覆盖材质来输出纯净的深度值或世界空间法线，而不受物体本身贴图和颜色的影响。

**核心优势：**
- ✅ 生成标准化的深度/法线数据
- ✅ 不受物体材质的干扰
- ✅ 支持 SSAO、SSR、边缘检测等后处理效果
- ✅ 可以在单独的 Pass 中高效生成

**应用效果：**
- 屏幕空间环境光遮蔽（SSAO）
- 屏幕空间反射（SSR）
- 边缘检测轮廓线
- 景深效果（Depth of Field）

#### 3. X-Ray/透视效果

**应用场景：**
当角色进入障碍物后面时，可以用一个半透明的覆盖材质来绘制它，实现透视效果。玩家可以透过墙壁看到角色的轮廓，类似于很多动作游戏中的效果。

**核心优势：**
- ✅ 实时动态响应遮挡情况
- ✅ 不需要修改原始材质
- ✅ 可以自定义透视的颜色和样式
- ✅ 支持分层渲染（如只对角色生效）

**实现效果：**
- 被遮挡的角色显示为半透明轮廓
- 通过墙壁看到队友的位置（多人游戏）
- 突出显示可交互物体（即使被遮挡）

#### 4. 后处理中的物体替换

**应用场景：**
在某些自定义效果中，你可能需要在后期阶段以不同的着色方式重新渲染场景中的某些物体。例如：热成像效果、夜视仪效果、或艺术风格化渲染。

**核心优势：**
- ✅ 灵活的视觉效果切换
- ✅ 不影响原始渲染结果
- ✅ 可以叠加多个效果
- ✅ 支持动态效果参数调整

**应用效果：**
- 热成像视野（红外效果）
- 夜视仪效果（绿色增强）
- 侦查模式（突出显示敌人）
- 艺术风格化（如漫画风格、素描风格）

---

**待完善：**
- [ ] 阴影投射的完整 Shader 实现和 Render Pass 代码
- [ ] 深度/法线纹理生成的完整流程和代码示例
- [ ] X-Ray 透视效果的实现（包括深度测试处理）
- [ ] 后处理物体替换的多种效果示例
- [ ] 性能对比和最佳实践建议
- [ ] 与其他技术的组合使用（如模板缓冲区）

[↑ 返回目录](#目录-table-of-contents)

