# 自定义渲染管线关键步骤

本文档总结自定义 Scriptable Render Pipeline (SRP) 的关键步骤和核心概念，基于当前项目实现和 [Catlike Coding 教程](https://catlikecoding.com/unity/tutorials/custom-srp)。

## 目录 (Table of Contents)

- [1. SRP 基础架构](#1-srp-基础架构)
  - [1.1 RenderPipeline 基类](#11-renderpipeline-基类)
  - [1.2 RenderPipelineAsset](#12-renderpipelineasset)
  - [1.3 ScriptableRenderContext](#13-scriptablerendercontext)
- [2. 相机渲染流程](#2-相机渲染流程)
  - [2.1 CameraRenderer 的职责](#21-camerarenderer-的职责)
  - [2.2 视锥剔除 (Cull)](#22-视锥剔除-cull)
  - [2.3 设置阶段 (Setup)](#23-设置阶段-setup)
  - [2.4 绘制阶段 (Draw)](#24-绘制阶段-draw)
  - [2.5 提交阶段 (Submit)](#25-提交阶段-submit)
- [3. 着色器标签系统](#3-着色器标签系统)
  - [3.1 ShaderTagId 的作用](#31-shadertagid-的作用)
  - [3.2 DrawingSettings 和 FilteringSettings](#32-drawingsettings-和-filteringsettings)
  - [3.3 传统着色器的处理](#33-传统着色器的处理)
- [4. 渲染队列和排序](#4-渲染队列和排序)
  - [4.1 RenderQueueRange](#41-renderqueuerange)
  - [4.2 SortingSettings](#42-sortingsettings)
  - [4.3 天空盒的渲染时机](#43-天空盒的渲染时机)
- [5. 命令缓冲区和上下文](#5-命令缓冲区和上下文)
  - [5.1 CommandBuffer 的用途](#51-commandbuffer-的用途)
  - [5.2 ExecuteBuffer 的执行时机](#52-executebuffer-的执行时机)
  - [5.3 Context.Submit() 的重要性](#53-contextsubmit-的重要性)
- [6. 编辑器支持](#6-编辑器支持)
  - [6.1 Partial Class 的使用](#61-partial-class-的使用)
  - [6.2 条件编译](#62-条件编译)
  - [6.3 Gizmos 绘制](#63-gizmos-绘制)
- [7. 后续扩展方向](#7-后续扩展方向)
  - [7.1 方向光（Directional Lights）](#71-方向光directional-lights)
  - [7.2 阴影系统（Shadows）](#72-阴影系统shadows)
  - [7.3 后处理（Post Processing）](#73-后处理post-processing)
  - [7.4 HDR 和颜色分级](#74-hdr-和颜色分级)
  - [7.5 其他高级特性](#75-其他高级特性)
- [参考资源](#参考资源)

---

## 1. SRP 基础架构

### 1.1 RenderPipeline 基类

`RenderPipeline` 是 Unity SRP 的核心基类，负责定义整个渲染流程。每个自定义渲染管线都需要继承此类。

**核心方法：**
- `Render(ScriptableRenderContext context, Camera[] cameras)`：每个渲染帧都会被调用，负责渲染所有相机

当前项目实现：

```5:20:Assets/Custom RP/Runtime/CustomRenderPipeline.cs
public class CustomRenderPipeline : RenderPipeline
{

    private CameraRenderer renderer;
    public CustomRenderPipeline()
    {
        renderer = new CameraRenderer();
    }
    protected override void Render(ScriptableRenderContext context, Camera[] cameras)
    {
        foreach(Camera camera in cameras)
        {
            renderer.Render(context, camera);
        }
    }
}
```

**关键点：**
- 在构造函数中创建 `CameraRenderer` 实例
- `Render` 方法遍历所有相机，为每个相机执行渲染
- `ScriptableRenderContext` 是渲染上下文，所有的渲染命令都通过它执行

### 1.2 RenderPipelineAsset

`RenderPipelineAsset` 是一个 ScriptableObject，用于在 Unity 编辑器中配置和创建渲染管线实例。

当前项目实现：

```5:13:Assets/Custom RP/Runtime/CustomRenderPipelineAsset.cs
[CreateAssetMenu(menuName = "Rendering/Custom Render Pipeline")]
public class CustomRenderPipelineAsset : RenderPipelineAsset
{
    protected override RenderPipeline CreatePipeline()
    {
        return new CustomRenderPipeline();
    }
}
```

**关键点：**
- `CreateAssetMenu` 属性允许在 Unity 编辑器中通过菜单创建资源
- `CreatePipeline()` 方法在运行时被调用，返回渲染管线实例
- 在 `GraphicsSettings` 中指定此 Asset 后，Unity 会使用自定义渲染管线

### 1.3 ScriptableRenderContext

`ScriptableRenderContext` 是 SRP 的核心接口，所有渲染操作都通过它执行：

- **延迟执行**：命令不会立即执行，而是记录在上下文中
- **批量提交**：通过 `Submit()` 一次性提交所有命令，提高效率
- **不可直接访问 GPU**：必须通过上下文间接操作

[↑ 返回目录](#目录-table-of-contents)

## 2. 相机渲染流程

### 2.1 CameraRenderer 的职责

`CameraRenderer` 负责单个相机的完整渲染流程：

```6:40:Assets/Custom RP/Runtime/CameraRenderer.cs
public partial class CameraRenderer
{
    // https://docs.unity3d.com/Manual/SL-PassTags.html
    private static ShaderTagId unlitShaderTagId = new ShaderTagId("SRPDefaultUnlit");
    
   private const string bufferName = "Render Camera";
    private ScriptableRenderContext context;
    private Camera camera;
    private CommandBuffer buffer;
    private CullingResults cullingResults;

    public CameraRenderer()
    {
        buffer = new CommandBuffer() {
            name = bufferName
        };
    }

    public void Render(ScriptableRenderContext context, Camera camera)
    {
        this.context = context;
        this.camera = camera;

        // Cull和GPU无关
        if (!Cull())
            return;

        Setup();

        DrawVisibleObjects();
        DrawUnsupportedShaders();
        DrawGizmos();

        Submit();
    }
```

**核心流程：Cull → Setup → Draw → Submit**

### 2.2 视锥剔除 (Cull)

剔除阶段确定哪些对象在相机视野内，无需渲染的对象将被过滤掉：

```82:91:Assets/Custom RP/Runtime/CameraRenderer.cs
    private bool Cull()
    {
        if (!camera.TryGetCullingParameters(out ScriptableCullingParameters parameters))
        {
            return false;
        }

        cullingResults = context.Cull(ref parameters);
        return true;
    }
```

**关键点：**
- `TryGetCullingParameters`：从相机获取剔除参数（视锥、遮挡剔除等）
- `Cull()` 返回 `CullingResults`，包含可见物体的信息
- 这是 CPU 端操作，不涉及 GPU

### 2.3 设置阶段 (Setup)

设置渲染目标、清理缓冲区、开始性能采样：

```42:48:Assets/Custom RP/Runtime/CameraRenderer.cs
    private void Setup()
    {
        context.SetupCameraProperties(camera);
        buffer.ClearRenderTarget(true, true, Color.clear);
        buffer.BeginSample(bufferName);
        ExecuteBuffer();
    }
```

**关键操作：**
- `SetupCameraProperties`：设置相机的投影矩阵、视图矩阵等
- `ClearRenderTarget`：清理颜色缓冲区和深度缓冲区
- `BeginSample`：开始性能分析采样（用于 Frame Debugger）

### 2.4 绘制阶段 (Draw)

绘制所有可见对象：

```50:66:Assets/Custom RP/Runtime/CameraRenderer.cs
    private void DrawVisibleObjects()
    {
        var sortingSettings = new SortingSettings(camera)
        {
            criteria = SortingCriteria.CommonOpaque
        };
        var drawingSettings = new DrawingSettings(unlitShaderTagId, sortingSettings);
        var filteringSettings = new FilteringSettings(RenderQueueRange.opaque);
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);

        context.DrawSkybox(camera);

        sortingSettings.criteria = SortingCriteria.CommonTransparent;
        drawingSettings.sortingSettings = sortingSettings;
        filteringSettings.renderQueueRange = RenderQueueRange.transparent;
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
    }
```

**渲染顺序：**
1. **不透明对象**：从前往后渲染（`CommonOpaque`）
2. **天空盒**：不透明对象之后
3. **透明对象**：从后往前渲染（`CommonTransparent`）

### 2.5 提交阶段 (Submit)

结束性能采样并提交所有渲染命令：

```68:74:Assets/Custom RP/Runtime/CameraRenderer.cs
    private void Submit()
    {
        buffer.EndSample(bufferName);
        ExecuteBuffer();

        context.Submit();
    }
```

**关键点：**
- `EndSample`：结束性能分析采样
- `ExecuteBuffer`：执行命令缓冲区中的所有命令
- `Submit()`：将上下文中的所有命令提交到 GPU，**这是实际执行渲染的时刻**

[↑ 返回目录](#目录-table-of-contents)

## 3. 着色器标签系统

### 3.1 ShaderTagId 的作用

`ShaderTagId` 用于标识着色器的 Pass 标签，告诉渲染管线哪些 Pass 应该被渲染：

```9:9:Assets/Custom RP/Runtime/CameraRenderer.cs
    private static ShaderTagId unlitShaderTagId = new ShaderTagId("SRPDefaultUnlit");
```

**SRPDefaultUnlit 标签：**
- Unity SRP 的默认无光照标签
- 如果着色器 Pass 没有显式声明 `LightMode`，默认被视为 `SRPDefaultUnlit`
- 用于标识不受光照影响的简单着色器

### 3.2 DrawingSettings 和 FilteringSettings

```56:58:Assets/Custom RP/Runtime/CameraRenderer.cs
        var drawingSettings = new DrawingSettings(unlitShaderTagId, sortingSettings);
        var filteringSettings = new FilteringSettings(RenderQueueRange.opaque);
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
```

**DrawingSettings：**
- 指定要渲染的着色器 Pass 标签（`ShaderTagId`）
- 包含排序设置（`SortingSettings`）
- 可以指定多个 Pass 标签，支持多 Pass 渲染

**FilteringSettings：**
- 指定渲染队列范围（`RenderQueueRange`）
- 可以按渲染类型（`RenderType`）过滤
- 可以按图层（`Layer`）过滤

### 3.3 传统着色器的处理

对于不兼容 SRP 的内置管线着色器，需要使用错误材质显示：

```14:49:Assets/Custom RP/Runtime/CameraRenderer.Editor.cs
#if UNITY_EDITOR || DEVELOPMENT_BUILD
    // https://docs.unity3d.com/Manual/shader-predefined-pass-tags-built-in.html
    static ShaderTagId[] legacyShaderTagIds = {
        new ShaderTagId("Always"),
        new ShaderTagId("ForwardBase"),
        new ShaderTagId("ForwardAdd"),
        new ShaderTagId("Deferred"),
        new ShaderTagId("ShadowCaster"),
        // TODO1 打开绘制失效
        //new ShaderTagId("MotionVectors"),
        new ShaderTagId("Vertex"),
        new ShaderTagId("VertexLMRGBM"),
        new ShaderTagId("VertexLM"),
        new ShaderTagId("Meta")
    };

    static Material errorMaterial;
    private partial void DrawUnsupportedShaders()
    {
        if (errorMaterial == null)
        {
            errorMaterial = new Material(Shader.Find("Hidden/InternalErrorShader"));
        }

        var drawingSettings = new DrawingSettings(legacyShaderTagIds[0], new SortingSettings(camera))
        {
            overrideMaterial = errorMaterial
        };
        for (int index=1; index<legacyShaderTagIds.Length; index++)
        {
            drawingSettings.SetShaderPassName(index, legacyShaderTagIds[index]);
        }

        var filterSettings = FilteringSettings.defaultValue;
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filterSettings);
    }
```

**关键点：**
- 传统着色器使用 `ForwardBase`、`ForwardAdd` 等标签
- 使用 `overrideMaterial` 将所有不支持的着色器替换为错误材质（粉红色）
- 这在编辑器中特别有用，可以清楚地看到哪些对象使用了不兼容的着色器

[↑ 返回目录](#目录-table-of-contents)

## 4. 渲染队列和排序

### 4.1 RenderQueueRange

渲染队列决定了对象的渲染顺序：

- **Opaque（不透明）**：值 < 2500，从前往后渲染
- **Transparent（透明）**：值 >= 2500，从后往前渲染

```57:58:Assets/Custom RP/Runtime/CameraRenderer.cs
        var filteringSettings = new FilteringSettings(RenderQueueRange.opaque);
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
```

### 4.2 SortingSettings

排序设置控制对象的渲染顺序：

```52:55:Assets/Custom RP/Runtime/CameraRenderer.cs
        var sortingSettings = new SortingSettings(camera)
        {
            criteria = SortingCriteria.CommonOpaque
        };
```

**常用排序标准：**
- `CommonOpaque`：不透明对象的标准排序（从前往后）
- `CommonTransparent`：透明对象的标准排序（从后往前）
- `SortingLayer`：按排序图层排序

### 4.3 天空盒的渲染时机

天空盒在不透明对象之后、透明对象之前渲染：

```60:60:Assets/Custom RP/Runtime/CameraRenderer.cs
        context.DrawSkybox(camera);
```

**原因：**
- 天空盒作为背景，应该在不透明对象之后绘制
- 深度测试确保不透明对象会遮挡天空盒
- 透明对象应该在天空盒之后渲染

[↑ 返回目录](#目录-table-of-contents)

## 5. 命令缓冲区和上下文

### 5.1 CommandBuffer 的用途

`CommandBuffer` 用于记录渲染命令，而不是立即执行：

```17:22:Assets/Custom RP/Runtime/CameraRenderer.cs
    public CameraRenderer()
    {
        buffer = new CommandBuffer() {
            name = bufferName
        };
    }
```

**优势：**
- 批量执行，减少状态切换
- 可以记录命令供后续使用
- 支持性能分析（通过命名）

### 5.2 ExecuteBuffer 的执行时机

```76:80:Assets/Custom RP/Runtime/CameraRenderer.cs
    private void ExecuteBuffer()
    {
        context.ExecuteCommandBuffer(buffer);
        buffer.Clear();
    }
```

**执行流程：**
1. `ExecuteCommandBuffer`：将缓冲区中的命令提交到上下文
2. `Clear()`：清空缓冲区，准备下一帧使用

**调用时机：**
- Setup 之后：确保清理操作立即执行
- Submit 之前：确保所有命令都已记录

### 5.3 Context.Submit() 的重要性

```73:73:Assets/Custom RP/Runtime/CameraRenderer.cs
        context.Submit();
```

**关键作用：**
- **所有渲染命令的实际执行点**：在此之前，所有命令只是被记录
- GPU 开始执行渲染：提交后 GPU 才会真正执行命令
- 必须调用：不调用 `Submit()` 就不会有任何渲染结果

[↑ 返回目录](#目录-table-of-contents)

## 6. 编辑器支持

### 6.1 Partial Class 的使用

使用 `partial class` 将编辑器相关代码分离：

```9:12:Assets/Custom RP/Runtime/CameraRenderer.Editor.cs
public partial class CameraRenderer
{
    private partial void DrawGizmos();
    private partial void DrawUnsupportedShaders();
```

**好处：**
- 代码组织清晰：运行时和编辑器代码分离
- 条件编译：编辑器代码可以只在编辑器中编译

### 6.2 条件编译

```14:14:Assets/Custom RP/Runtime/CameraRenderer.Editor.cs
#if UNITY_EDITOR || DEVELOPMENT_BUILD
```

**作用：**
- `UNITY_EDITOR`：仅在编辑器中编译
- `DEVELOPMENT_BUILD`：在开发构建中包含，发布版本中移除
- 减少发布版本的大小和性能开销

### 6.3 Gizmos 绘制

```51:58:Assets/Custom RP/Runtime/CameraRenderer.Editor.cs
    private partial void DrawGizmos()
    {
        if (Handles.ShouldRenderGizmos())
        {
            context.DrawGizmos(camera, GizmoSubset.PreImageEffects);
            context.DrawGizmos(camera, GizmoSubset.PostImageEffects);
        }
    }
```

**GizmoSubset：**
- `PreImageEffects`：图像效果之前的 Gizmos（如碰撞器轮廓）
- `PostImageEffects`：图像效果之后的 Gizmos（如 UI 相关）

[↑ 返回目录](#目录-table-of-contents)

## 7. 后续扩展方向

基于 [Catlike Coding 教程](https://catlikecoding.com/unity/tutorials/custom-srp)，以下是可以扩展的功能：

### 7.1 方向光（Directional Lights）
- 添加光源数据结构
- 在着色器中实现简单光照计算
- 支持多光源

### 7.2 阴影系统（Shadows）
- 实现阴影贴图渲染
- 支持方向光阴影
- 点光源和聚光灯阴影

### 7.3 后处理（Post Processing）
- 实现颜色校正
- 模糊效果
- 色调映射

### 7.4 HDR 和颜色分级
- 支持 HDR 渲染
- 实现色调映射（Tone Mapping）
- 颜色分级（Color Grading）

### 7.5 其他高级特性
- LOD（细节层次）支持
- 反射探针
- 多相机支持
- 粒子系统集成

[↑ 返回目录](#目录-table-of-contents)

## 参考资源

- [Catlike Coding - Custom SRP 教程](https://catlikecoding.com/unity/tutorials/custom-srp)
- [Unity 官方文档 - Scriptable Render Pipeline](https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html)
- [Unity 官方文档 - ShaderLab Pass Tags](https://docs.unity3d.com/Manual/SL-PassTags.html)

[↑ 返回目录](#目录-table-of-contents)
